using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ProjectEulerLibrary
{
    /// <summary>
    /// Class contains methods reBlated to mathematical calculations.
    /// </summary>
    public class Mathematics
    {
        public static int ERROR = -1;

        /// <summary>
        /// Method gets the number of digits in a number.
        /// </summary>
        /// <param name="num">Number for which the number of digits will be calculated.</param>
        /// <returns>Number of digits.</returns>
        public static int GetNumOfDigits(long num)
        {
            if (num >= 0)
            {
                return num.ToString().Length;
            }
            else
            {
                return num.ToString().Length - 1;
            }
        }

        /// <summary>
        /// Method calculates the number of factors for a given number.
        /// </summary>
        /// <param name="num">Number for which the number of factors will be calculated.</param>
        /// <returns>Number of factors.</returns>
        public static int GetNumOfFactors(int num)
        {
            // Check that num is greater than 0.
            if (num <= 0)
            {
                throw new ArgumentOutOfRangeException("num", "num must be greater than or equal to one.");
            }

            // Find the floor of the square root of num.  This will be used as the max loop value.
            int maxIndex = (int)Math.Floor(Math.Sqrt(num));

            int numFactors = 0;

            // Loop from 1 to the max loop value.
            for (int i = 1; i < maxIndex; i++)
            {
                // Check to see if the current loop index cleanly divides num.
                if (num % i == 0)
                {
                    numFactors += 2;
                }
            }
            
            // Check if the maxIndex divides num cleanly.
            // If it does, it is the square root of num.  Incrememnt numFactors by one.
            if (num % maxIndex == 0)
            {
                numFactors++;
            }

            return numFactors;
        }

        /// <summary>
        /// Method gets all of the factors for a specified number.
        /// </summary>
        /// <param name="num">Number for which the factors will be calculated.</param>
        /// <returns>List of factors.</returns>
        public static List<int> GetFactors(int num)
        {
            // Check that num is greater than 0.
            if (num <= 0)
            {
                throw new ArgumentOutOfRangeException("num", "num must be greater than or equal to one.");
            }

            // Find the floor of the square root of num.  This will be used as the max loop value.
            int maxIndex = (int)Math.Floor(Math.Sqrt(num));

            List<int> factors = new List<int>();

            // Loop from 1 to the max loop value.
            for (int i = 1; i <= maxIndex; i++)
            {
                // Check to see if the current loop index cleanly divides num.
                if (num % i == 0)
                {
                    // If it does, then add the current loop index and num divided by current loop index to the factors list.
                    factors.Add(i);
                    factors.Add(num / i);
                }
            }
            // Remove duplicates and sort list of factors.
            factors = factors.Distinct().ToList();
            factors.Sort();
            
            // Return list of factors.
            return factors;
        }

        /// <summary>
        /// Method gets the first n triangle numbers.  The sequence of triangle numbers is generated by adding the natural numbers.
        /// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
        /// </summary>
        /// <param name="n">Number of triangle numbers to get.</param>
        /// <returns>List of triangle numbers.</returns>
        public static List<int> GetTriangleNums(int n)
        {
            // Check that input is positive.
            if (n <= 0)
            {
                throw new ArgumentOutOfRangeException("n", "n cannot be zero or negative");
            }
            // Add first triangle number to the list.
            List<int> triangleNums = new List<int>() { 1 };

            // Loop from second triangle number to num.
            for (int i = 2; i <= n; i++)
            {
                // Use previous triangle number and add loop index to it.
                triangleNums.Add(triangleNums[i - 2] + i);
            }

            return triangleNums;
        }

        /// <summary>
        /// Method determines if a floating point number is an integer.
        /// </summary>
        /// <param name="num">Floating point number.</param>
        /// <returns>Bool indicating if a floating point number is an integer or not.</returns>
        public static bool IsInteger(double num)
        {
            if (num % 1 == 0)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Method calculates the sum of the numbers from a specified starting number to a specified
        /// ending number.
        /// </summary>
        /// <param name="startNum">Number to start calculating the sum from.</param>
        /// <param name="stopNum">Number to stop calculating the sum from.</param>
        /// <returns>Sum of consecutive numbers.</returns>
        public static int GetSumOfConsecutiveNumbers(int startNum, int stopNum)
        {
            // Check inputs.
            if (stopNum < startNum)
            {
                throw new ArgumentOutOfRangeException("stopNum must be greater than or equal to startNum", "stopNum");
            }
            if (startNum <= 0)
            {
                throw new ArgumentOutOfRangeException("startNum", "startNum must consist of a positive integer.");
            }

            // If amount of consecutive numbers is even.
            if (IsEven(stopNum - startNum + 1))
            {
                return (startNum + stopNum) * (stopNum - startNum + 1) / 2;
            }
            else // Amount of consecutive numbers is odd.
            {
                return ((startNum + stopNum) * (stopNum - startNum) / 2) + ((startNum + stopNum) / 2);
            }
        }

        /// <summary>
        /// Method calculates the sum of the squares from a specified starting number to a specified
        /// ending number.
        /// </summary>
        /// <param name="startNum">Number to start calculating squares from.</param>
        /// <param name="stopNum">Number to stop calculating squares from.</param>
        /// <returns>Sum of squares.</returns>
        public static int GetSumOfConsecutivePositiveSquares(int startNum, int stopNum)
        {
            // Check inputs.
            if (stopNum < startNum)
            {
                throw new ArgumentOutOfRangeException("stopNum must be greater than or equal to startNum", "stopNum");
            }
            if (startNum <= 0)
            {
                throw new ArgumentOutOfRangeException("startNum", "startNum must consist of a positive integer.");
            }
            if (stopNum > Math.Sqrt(int.MaxValue))
            {
                throw new ArgumentOutOfRangeException("stopNum", @"stopNum must be less than or equal to the square root of the 
                    maximum possible int value (2^32).");
            }

            int sum = 0;
            for (int i = startNum; i <= stopNum; i++)
            {
                sum += i * i;
            }

            return sum;
        }

        /// <summary>
        /// Method determines if a number is even.
        /// </summary>
        /// <param name="num">Number.</param>
        /// <returns>Bool indicating if a number is even or not.</returns>
        public static bool IsEven(int num)
        {
            if (num % 2 == 0)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Method determines if a number is odd.
        /// </summary>
        /// <param name="num">Number.</param>
        /// <returns>Bool indicating if a number is odd or not.</returns>
        public static bool IsOdd(int num)
        {
            if (Math.Abs(num % 2) == 1)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Method calculates the least common multiple from a list of numbers.
        /// Pre-assumptions: The resulting least common multiple is less than the max possible integer value (2^32).
        /// </summary>
        /// <param name="nums">List of numbers.</param>
        /// <returns>Least common multiple.</returns>
        public static int GetLeastCommonMultiple(List<int> nums)
        {
            // Check input.
            if (nums == null || nums.Count == 0)
            {
                throw new ArgumentException("nums list cannot be null or empty.", "nums");
            }
            
            // Create a list to track the multiples of each number.
            List<int> numTracker = nums.ToList();
            
            // Get the max index and value.
            int maxValue = GetMaxNum(nums);
            int maxIndex = GetMaxNumIndex(nums);

            // Let each of the nums "catch up" to the max.
            while (true)
            {
                // Increment each element until it is equal to or greater than max value.
                for (int i = 0; i < numTracker.Count; i++)
                {
                    while (numTracker[i] < maxValue)
                    {
                        numTracker[i] += nums[i];
                    }
                }

                // If all elements are equal to the max value, then max value is the least common multiple.
                if (AreElementsEqualToNum(numTracker, maxValue))
                {
                    break;
                }

                maxValue = numTracker[maxIndex] += nums[maxIndex];
            }

            return maxValue;
        }

        /// <summary>
        /// Method checks to see if all of the elements in a list are equal to the specified number.
        /// </summary>
        /// <param name="nums">List of numbers.</param>
        /// <param name="comparisonNum">Comparison number.</param>
        /// <returns>Bool value indicating if all of the elements in a list are equal to the specified number.</returns>
        public static bool AreElementsEqualToNum(List<int> nums, int comparisonNum)
        {
            // Check input.
            if (nums == null || nums.Count == 0)
            {
                throw new ArgumentException("nums list cannot be null or empty.", "nums");
            }

            foreach (int num in nums)
            {
                if (num != comparisonNum)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Method gets the index of the maximum number in a list of numbers.  If there are multiple maximum numbers in the list,
        /// the method will return the index of the first occurrence of the maximum number.
        /// </summary>
        /// <param name="nums">List of numbers.</param>
        /// <returns>Index of the maximum number.</returns>
        public static int GetMaxNumIndex(List<int> nums)
        {
            // Check input.
            if (nums == null || nums.Count == 0)
            {
                throw new ArgumentException("nums list cannot be null or empty.", "nums");
            }

            int max = int.MinValue;
            int maxIndex = -1;
            for(int i = 0; i < nums.Count; i++)
            {
                if (nums[i] > max)
                {
                    max = nums[i];
                    maxIndex = i;
                }
            }

            return maxIndex;
        }

        /// <summary>
        /// Method gets the maximum number from a list of numbers.
        /// </summary>
        /// <param name="nums">List of numbers.</param>
        /// <returns>Maximum number.</returns>
        public static int GetMaxNum(List<int> nums)
        {
            // Check input.
            if (nums == null || nums.Count == 0)
            {
                throw new ArgumentException("nums list cannot be null or empty.", "nums");
            }

            int max = int.MinValue;
            foreach (int num in nums)
            {
                if (num > max)
                {
                    max = num;
                }
            }

            return max;
        }

        /// <summary>
        /// Method determines if an integer is a palindrome or not.  In this method, negative numbers are not considered to be palindromic.
        /// </summary>
        /// <param name="num">Possible palindromic number.</param>
        /// <returns>Bool indicating if a number is a palindrome or not.</returns>
        public static bool IsPalindrome(int num)
        {
            // Check input.
            if (num < 0)
            {
                return false;
            }

            // Convert number to string for easier indexing.
            string numAsString = num.ToString();

            // Set left, right pointers.
            int left = 0;
            int right = numAsString.Length - 1;

            // While left pointer is less than right pointer.
            while (left < right)
            {
                // Compare characters.  If they are different return false.
                if (numAsString[left] != numAsString[right])
                {
                    return false;
                }
                left++;
                right--;
            }

            return true;
        }

        /// <summary>
        /// Method gets all multiples of a number which are less than a specified maximum value.
        /// </summary>
        /// <param name="num">Number for which the multiples will be calculated.</param>
        /// <param name="max">Multiples will be calculated up to this value.</param>
        /// <returns>List of multiples.</returns>
        public static List<int> GetMultiples(int num, int max)
        {
            // Check inputs.
            if (num <= 0)
            {
                throw new ArgumentOutOfRangeException("num", "num parameter must consist of a positive integer value.");
            }
            if (max <= 0)
            {
                throw new ArgumentOutOfRangeException("max", "max parameter must consist of a positive integer value.");
            }
            if(max <= num)
            {
                throw new ArgumentOutOfRangeException("max", "max parameter value must be greater than num parameter value.");
            }
            
            List<int> multiples = new List<int>();

            for (int i = num; i < max; i += num)
            {
                multiples.Add(i);
            }

            return multiples;
        }

        /// <summary>
        /// Method gets the prime numbers less than or equal to the specified max value by using the
        /// Sieve of Eratosthenes algorithm.
        /// </summary>
        /// <param name="max">Max value.</param>
        /// <returns>List of prime numbers less than or equal to the specified max value.</returns>
        public static List<int> GetPrimeNums(int max)
        {
            List<EratosthenesNode> primeNums = new List<EratosthenesNode>();

            // Initially populate list with 2 dummy nodes to keep the list index in line with the number values.
            primeNums.Add(new EratosthenesNode(0, false));
            primeNums.Add(new EratosthenesNode(0, false));

            // Populate list with all ints from 2 to max.
            for (int i = 2; i <= max; i++)
            {
                primeNums.Add(new EratosthenesNode(i));
            }

            // Calculate floor of the square root of max.  You only need to go up to the square root due to the following explanation:
            // http://stackoverflow.com/questions/5811151/why-do-we-check-upto-the-square-root-of-a-prime-number-to-determine-if-it-is-pri
            int stopNum = (int)Math.Floor(Math.Sqrt(max));

            for (int j = 2; j <= stopNum; j++)
            {
                int startNum = j * j;
                for (int k = startNum; k < primeNums.Count; k++)
                {
                    if (primeNums[k].Value % j == 0)
                    {
                        primeNums[k].IsPrime = false;
                    }
                }
            }

            // Create a list consisting of the node values which are prime.
            return primeNums.Where(x => x.IsPrime).Select(x => x.Value).ToList();
        }

        /// <summary>
        /// Method gets all Fibonacci numbers below the specified max value by using dynamic programming.
        /// </summary>
        /// <param name="max">Max value.</param>
        /// <returns>List of all Fibonacci numbers below the specified max value.</returns>
        public static List<int> GetFibonacciNums(int max)
        {
            // Check input.
            if (max <= 0)
            {
                throw new ArgumentOutOfRangeException("max", "max value must be greater than one.");
            }
            if (max == 1)
            {
                return new List<int>() { 0 };
            }

            // Create return list.
            List<int> fibonacciNums = new List<int>();

            // Set the first two values.
            fibonacciNums.Insert(0, 0);
            fibonacciNums.Insert(1, 1);

            int index = 2;

            while (true)
            {
                int currentNum = fibonacciNums[index - 1] + fibonacciNums[index - 2];
                if (currentNum < max)
                {
                    fibonacciNums.Insert(index, currentNum);
                }
                else
                {
                    break;
                }

                index++;
            }

            return fibonacciNums;
        }
    }
}
